from playwright.sync_api import sync_playwright
import requests
import pdfplumber

DOCUMENT_ID = "12345"
PDF_FILENAME = "document.pdf"
PAGE_URL = "https://your-document-page.com"

with sync_playwright() as p:
    browser = p.chromium.launch(headless=False)  # set True for headless
    page = browser.new_page()
    
    # Go to your document search page
    page.goto(PAGE_URL)

    # Fill in the document ID
    page.fill("#document_id", DOCUMENT_ID)  # Replace with actual selector

    # Click the search button
    page.click("#search_button")  # Replace with actual selector

    # Wait for search results to load
    page.wait_for_selector("a#view_pdf_link")  # Replace with actual selector

    # Get the PDF link
    pdf_url = page.get_attribute("a#view_pdf_link", "href")
    print("PDF URL:", pdf_url)

    # Download the PDF using requests
    response = requests.get(pdf_url)
    with open(PDF_FILENAME, "wb") as f:
        f.write(response.content)

    print("PDF downloaded successfully!")

    browser.close()

with pdfplumber.open(PDF_FILENAME) as pdf:
    text = ""
    for page in pdf.pages:
        text += page.extract_text() + "\n"

print("Extracted PDF text:")
print(text)

editable = page.locator("input, textarea, [contenteditable=true]")
print("editable count:", editable.count())

for i in range(editable.count()):
    el = editable.nth(i)
    print({
        "tag": el.evaluate("e => e.tagName"),
        "type": el.get_attribute("type"),
        "visible": el.is_visible(),
        "class": el.get_attribute("class"),
    })



//Arnab
frame = page.frame_locator("iframe")

# find *any* editable input
search_input = frame.locator("input").filter(has_text="").first
search_input.fill("APPLICATION_ID_123")

frame.locator("button", has_text="Search").click()

with page.expect_response(lambda r: "search" in r.url and r.status == 200):
    frame.locator("button", has_text="Search").click()



docs_response = None

def is_docs_api(resp):
    return "documents" in resp.url and resp.status == 200

page.on("response", lambda r: globals().update(docs_response=r) if is_docs_api(r) else None)

page.goto(f"https://site/view?applicationId={app_id}")
page.wait_for_timeout(3000)


with page.expect_response(lambda r: "documents" in r.url):
    page.goto(f"https://site/view?applicationId={app_id}")

resp = page.expect_response
docs = resp.value.json()


[
  {
    "documentId": "abc123",
    "name": "Application Form",
    "type": "PDF"
  }
]

documents = docs.json()

for doc in documents:
    print(doc["documentId"], doc["name"])
pdf_urls = [
    f"https://site/api/document/{doc['documentId']}/pdf"
    for doc in documents
]



raw = resp.body()
text = raw.decode("utf-8", errors="replace")

print("URL:", resp.url)
print("Status:", resp.status)
print("Content-Type:", resp.headers.get("content-type"))
print("Encoding:", resp.headers.get("content-encoding"))
print("---- BODY START ----")
print(text[:30000])
print("---- BODY END ----")


//Arnab

with page.expect_response(
    lambda r: "/API/gallery-get-doc/" in r.url
) as resp_info:
    page.locator("button").filter(has_text="View").click()

resp = resp_info.value
print("Download URL:", resp.url)

2

pdf_resp = context.request.get(resp.url)

print(pdf_resp.status)
print(pdf_resp.headers.get("content-type"))

with open("document.pdf", "wb") as f:
    f.write(pdf_resp.body())


with open("document.pdf", "wb") as f:
    f.write(resp.body())


buttons = page.locator("button, [role=button], a")
print("Total clickable elements:", buttons.count())

for i in range(buttons.count()):
    el = buttons.nth(i)
    try:
        print(i, el.inner_text(), el.get_attribute("class"))
    except:
        pass

####
page.goto(view_page_url)
page.wait_for_load_state("networkidle")

frame = page.main_frame  # or correct iframe if needed

frame.wait_for_selector("button.viewDocButton")

with page.expect_response(
    lambda r: "gallery-get-doc" in r.url
) as resp_info:
    frame.locator("button.viewDocButton").first.click(force=True)

pdf_resp = resp_info.value

with open("document.pdf", "wb") as f:
    f.write(pdf_resp.body())

print("PDF downloaded successfully")



/JS

page.goto(view_page_url, wait_until="domcontentloaded")

# Debug: verify that JS sees the button
count = page.evaluate("() => document.querySelectorAll('.viewDocButton').length")
print("JS sees view buttons:", count)

# Click using JS
with page.expect_download(timeout=20000) as d:
    page.evaluate("""
    () => {
      const btn = document.querySelector('.viewDocButton');
      if (btn) btn.click();
    }
    """)

d.value.save_as("document.pdf")

print("PDF downloaded successfully")

//shadow

shadow_info = page.evaluate("""
() => {
  const all = document.querySelectorAll('*');
  let open = 0;
  let closed = 0;

  for (const el of all) {
    if (el.shadowRoot) open++;
    if (el.tagName.includes('-')) closed++; // heuristic
  }
  return { openShadowRoots: open, customElements: closed };
}
""")

print(shadow_info)


///wwww
# Start listening for a new page
with context.expect_page() as new_page_info:
    page.evaluate("""
    () => {
        const btn = document.querySelector('.viewDocButton');
        if (btn) btn.click();
    }
    """)
new_page = new_page_info.value
new_page.wait_for_load_state("load")

# Now try to save it
content = new_page.content()
# If the page itself is the PDF (URL ends with .pdf)
pdf_url = new_page.url
response = new_page.request.get(pdf_url)
with open("document.pdf", "wb") as f:
    f.write(response.body())
print("Downloaded via new page.")

//Arnab

import base64

# Wait until PDF is actually ready
new_page.wait_for_function("""
() => {
  return window.PDFViewerApplication ||
         document.querySelector('embed[type="application/pdf"], iframe');
}
""", timeout=30000)

# Pull PDF bytes from browser memory
pdf_base64 = new_page.evaluate("""
async () => {

  // Case 1: PDF.js viewer (most common)
  if (window.PDFViewerApplication) {
    const data = await window.PDFViewerApplication.pdfDocument.getData();
    return btoa(String.fromCharCode(...data));
  }

  // Case 2: embed / iframe
  const el = document.querySelector('embed, iframe');
  if (!el) return null;

  const resp = await fetch(el.src);
  const buf = await resp.arrayBuffer();
  return btoa(String.fromCharCode(...new Uint8Array(buf)));
}
""")

if not pdf_base64:
    raise Exception("Failed to extract PDF bytes")

# Decode and save
pdf_bytes = base64.b64decode(pdf_base64)
with open("document.pdf", "wb") as f:
    f.write(pdf_bytes)

print("‚úÖ PDF saved correctly")

//Download js
with new_page.expect_download(timeout=30000) as d:
    new_page.evaluate("""
    () => {
        const btn =
            document.querySelector('[title*="Download"]') ||
            document.querySelector('[aria-label*="Download"]') ||
            document.querySelector('button[class*="download"]') ||
            document.querySelector('a[href*="download"]');

        if (!btn) throw "Download button not found";
        btn.click();
    }
    """)

download = d.value
download.save_as("document.pdf")

print("‚úÖ PDF downloaded via UI button")

//Krypto
from playwright.sync_api import sync_playwright

with sync_playwright() as p:
    browser = p.chromium.launch(headless=False)
    page = browser.new_page()

    page.goto("https://internal.company.com/git/kryptojs")

    page.fill("#inputText", "hello")
    page.fill("#key", "secret")
    page.click("#encryptBtn")

    result = page.text_content("#outputText")
    print(result)

    browser.close()


page.goto(INITIAL_URL, wait_until="domcontentloaded")

# Let OAuth + SPA settle
page.wait_for_function("""
() => document.body.innerText.includes("Search Documents") ||
      document.querySelector('input[type="password"]')
""", timeout=0)

if page.locator("text=Search Documents").count() == 0:
    print("üîê Logging in...")

    page.wait_for_selector("text=Search Documents", timeout=0)
    context.storage_state(path="auth.json")
    print("‚úÖ auth.json refreshed")
else:
    print("‚úÖ Using existing session")


page.wait_for_selector(
    """
    button:has-text("Approve"),
    button:has-text("Reject"),
    text=/received your information|thank you for considering/i
    """,
    timeout=15_000
)

state = "unknown"

if page.get_by_role("button", name="Approve").is_visible():
    state = "approve"
elif page.get_by_role("button", name="Reject").is_visible():
    state = "reject"
elif page.locator("text=/received your information/i").is_visible():
    state = "submitted"
elif page.locator("text=/thank you for considering/i").is_visible():
    state = "thank_you"









