type InputTransformer = {
  InputPathsMap?: Record<string, string>;
  InputTemplate?: string;
};

private buildInputTransformer1(inputTransformer: any) {
  const inputPathsMap = inputTransformer?.InputPathsMap || {};
  let inputTemplate = inputTransformer?.InputTemplate || '{}';

  for (const [key, path] of Object.entries(inputPathsMap)) {
    const placeholder = `<${key}>`;
    if (inputTemplate.includes(placeholder)) {
      inputTemplate = inputTemplate.replaceAll(placeholder, `\${${path}}`);
    }
  }

  return {
    inputPathsMap,
    inputTemplate,
  };
}

function buildInputTransformer(inputTransformer: InputTransformer) {
  const inputPathsMap = inputTransformer?.InputPathsMap || {};
  let inputTemplate = inputTransformer?.InputTemplate || '{}';

  // Replace placeholders in template with AWS EventField references
  for (const [key, path] of Object.entries(inputPathsMap)) {
    const placeholder = `<${key}>`;
    if (inputTemplate.includes(placeholder)) {
      inputTemplate = inputTemplate.replace(
        new RegExp(placeholder, 'g'),
        `\${${path}}`
      );
    }
  }

  return {
    inputPathsMap,
    inputTemplate,
  };
}

// Example test data
const inputTransformer: InputTransformer = {
  InputPathsMap: {
    decisionOutcomeId: "$.detail.decisionOutcomeId",
    decisionOutcomeRequestId: "$.detail.decisionOutcomeRequestId"
  },
  InputTemplate:
    "{\"sourceSystem\": \"test\",\"workflowStageType\": \"CONCERN_INITIATED\",\"decisionOutcomeRequestContext\": {\"decisionOutcomeRequestId\": <decisionOutcomeRequestId>},\"decisionOutcomeContextItems\": [{\"decisionOutcomeId\": <decisionOutcomeId>}]}"
};

const inputTransformer1: InputTransformer = {
  InputPathsMap: {
    decisionOutcomeId: "$.detail.decisionOutcomeId",
    decisionOutcomeRequestId: "$.detail.decisionOutcomeRequestId",
    sourceSystem: "$.detail.sourceSystem"
  },
  InputTemplate:
    "{\"sourceSystem\": <sourceSystem>,\"workflowStageType\": \"CONCERN_INITIATED\",\"decisionOutcomeRequestContext\": {\"decisionOutcomeRequestId\": <decisionOutcomeRequestId>},\"decisionOutcomeContextItems\": [{\"decisionOutcomeId\": <decisionOutcomeId>}]}"
};

// Run test
const result = buildInputTransformer(inputTransformer);
console.log("ARnab");
console.log(JSON.stringify(result, null, 2));

const result1 = buildInputTransformer(inputTransformer1);
console.log("ARnab2");
console.log(JSON.stringify(result1, null, 2));


private buildInputTransformer(inputTransformer: any) {
  const inputPathsMap = inputTransformer?.InputPathsMap || {};
  let inputTemplate = inputTransformer?.InputTemplate || '{}';

  // Replace placeholders like <decisionOutcomeId> with ${$.detail.decisionOutcomeId}
  for (const [key, path] of Object.entries(inputPathsMap)) {
    const placeholder = `<${key}>`;
    if (inputTemplate.includes(placeholder)) {
      inputTemplate = inputTemplate.replace(
        new RegExp(placeholder, 'g'),
        `\${${path}}`
      );
    }
  }

  // âœ… Return actual InputTransformer structure for CDK
  return {
    InputPathsMap: Object.fromEntries(
      Object.entries(inputPathsMap).map(([key, path]) => [key, events.EventField.fromPath(path.toString())])
    ),
    InputTemplate: inputTemplate,
  };
}

import Mustache from 'mustache';

interface InputTransformer {
  InputPathsMap?: Record<string, string>;
  InputTemplate?: string;
}

interface TransformerResult {
  inputPathsMap: Record<string, string>;
  messageObject: Record<string, any>;
}

/**
 * Safely builds EventBridge input transformer object
 * from a template with static and dynamic fields.
 */
export function buildInputTransformer(inputTransformer: InputTransformer): TransformerResult {
  const inputPathsMap = inputTransformer?.InputPathsMap || {};
  const inputTemplate = inputTransformer?.InputTemplate || '{}';

  // Build a message object where dynamic fields are EventField references
  const messageObject: Record<string, any> = {};
  for (const [key, path] of Object.entries(inputPathsMap)) {
    messageObject[key] = `\${${path}}`; // placeholder string for EventField
  }

  // Render the template using Mustache with the messageObject
  // Mustache will only replace the placeholders present in inputPathsMap
  const rendered = Mustache.render(inputTemplate, messageObject);

  let parsed: Record<string, any> = {};
  try {
    parsed = JSON.parse(rendered);
  } catch (err) {
    console.warn('InputTemplate could not be fully parsed, returning as string:', err);
    // fallback: keep as string or partial object
  }

  return {
    inputPathsMap,
    messageObject: parsed,
  };
}



