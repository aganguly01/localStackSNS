type InputTransformer = {
  InputPathsMap?: Record<string, string>;
  InputTemplate?: string;
};

private buildInputTransformer1(inputTransformer: any) {
  const inputPathsMap = inputTransformer?.InputPathsMap || {};
  let inputTemplate = inputTransformer?.InputTemplate || '{}';

  for (const [key, path] of Object.entries(inputPathsMap)) {
    const placeholder = `<${key}>`;
    if (inputTemplate.includes(placeholder)) {
      inputTemplate = inputTemplate.replaceAll(placeholder, `\${${path}}`);
    }
  }

  return {
    inputPathsMap,
    inputTemplate,
  };
}

function buildInputTransformer(inputTransformer: InputTransformer) {
  const inputPathsMap = inputTransformer?.InputPathsMap || {};
  let inputTemplate = inputTransformer?.InputTemplate || '{}';

  // Replace placeholders in template with AWS EventField references
  for (const [key, path] of Object.entries(inputPathsMap)) {
    const placeholder = `<${key}>`;
    if (inputTemplate.includes(placeholder)) {
      inputTemplate = inputTemplate.replace(
        new RegExp(placeholder, 'g'),
        `\${${path}}`
      );
    }
  }

  return {
    inputPathsMap,
    inputTemplate,
  };
}

// Example test data
const inputTransformer: InputTransformer = {
  InputPathsMap: {
    decisionOutcomeId: "$.detail.decisionOutcomeId",
    decisionOutcomeRequestId: "$.detail.decisionOutcomeRequestId"
  },
  InputTemplate:
    "{\"sourceSystem\": \"test\",\"workflowStageType\": \"CONCERN_INITIATED\",\"decisionOutcomeRequestContext\": {\"decisionOutcomeRequestId\": <decisionOutcomeRequestId>},\"decisionOutcomeContextItems\": [{\"decisionOutcomeId\": <decisionOutcomeId>}]}"
};

const inputTransformer1: InputTransformer = {
  InputPathsMap: {
    decisionOutcomeId: "$.detail.decisionOutcomeId",
    decisionOutcomeRequestId: "$.detail.decisionOutcomeRequestId",
    sourceSystem: "$.detail.sourceSystem"
  },
  InputTemplate:
    "{\"sourceSystem\": <sourceSystem>,\"workflowStageType\": \"CONCERN_INITIATED\",\"decisionOutcomeRequestContext\": {\"decisionOutcomeRequestId\": <decisionOutcomeRequestId>},\"decisionOutcomeContextItems\": [{\"decisionOutcomeId\": <decisionOutcomeId>}]}"
};

// Run test
const result = buildInputTransformer(inputTransformer);
console.log("ARnab");
console.log(JSON.stringify(result, null, 2));

const result1 = buildInputTransformer(inputTransformer1);
console.log("ARnab2");
console.log(JSON.stringify(result1, null, 2));


private buildInputTransformer(inputTransformer: any) {
  const inputPathsMap = inputTransformer?.InputPathsMap || {};
  let inputTemplate = inputTransformer?.InputTemplate || '{}';

  // Replace placeholders like <decisionOutcomeId> with ${$.detail.decisionOutcomeId}
  for (const [key, path] of Object.entries(inputPathsMap)) {
    const placeholder = `<${key}>`;
    if (inputTemplate.includes(placeholder)) {
      inputTemplate = inputTemplate.replace(
        new RegExp(placeholder, 'g'),
        `\${${path}}`
      );
    }
  }

  // ✅ Return actual InputTransformer structure for CDK
  return {
    InputPathsMap: Object.fromEntries(
      Object.entries(inputPathsMap).map(([key, path]) => [key, events.EventField.fromPath(path.toString())])
    ),
    InputTemplate: inputTemplate,
  };
}

import Mustache from 'mustache';

interface InputTransformer {
  InputPathsMap?: Record<string, string>;
  InputTemplate?: string;
}

interface TransformerResult {
  inputPathsMap: Record<string, string>;
  messageObject: Record<string, any>;
}

/**
 * Safely builds EventBridge input transformer object
 * from a template with static and dynamic fields.
 */
export function buildInputTransformer(inputTransformer: InputTransformer): TransformerResult {
  const inputPathsMap = inputTransformer?.InputPathsMap || {};
  const inputTemplate = inputTransformer?.InputTemplate || '{}';

  // Build a message object where dynamic fields are EventField references
  const messageObject: Record<string, any> = {};
  for (const [key, path] of Object.entries(inputPathsMap)) {
    messageObject[key] = `\${${path}}`; // placeholder string for EventField
  }

  // Render the template using Mustache with the messageObject
  // Mustache will only replace the placeholders present in inputPathsMap
  const rendered = Mustache.render(inputTemplate, messageObject);

  let parsed: Record<string, any> = {};
  try {
    parsed = JSON.parse(rendered);
  } catch (err) {
    console.warn('InputTemplate could not be fully parsed, returning as string:', err);
    // fallback: keep as string or partial object
  }

  return {
    inputPathsMap,
    messageObject: parsed,
  };


//Final Arnab
import Mustache from 'mustache';
import * as events from 'aws-cdk-lib/aws-events';

export function buildInputTransformer(inputTransformer: any) {
  const inputPathsMap = inputTransformer?.InputPathsMap || {};
  const includeTemplate = inputTransformer?.InputTemplate || '{}';

  // Step 1: Replace placeholders with EventField.fromPath
  const messageObject: Record<string, any> = {};
  for (const [key, path] of Object.entries(inputPathsMap)) {
    messageObject[key] = events.EventField.fromPath(path.toString());
  }

  // Step 2: Render Mustache so <placeholders> remain intact but JSON can parse
  let parsedTemplate: Record<string, any> = {};
  try {
    const rendered = Mustache.render(includeTemplate, {}); // placeholders remain
    parsedTemplate = JSON.parse(rendered);
  } catch (err) {
    console.warn('⚠️ Could not fully parse InputTemplate JSON. Static fields may be partially included.');
  }

  // Step 3: Merge static fields not already in messageObject
  for (const [key, value] of Object.entries(parsedTemplate)) {
    if (!(key in messageObject)) {
      messageObject[key] = value;
    }
  }

  return {
    inputPathsMap,
    messageObject
  };
}


const inputTransformer = {
  InputPathsMap: {
    decisionOutcomeId: '$.detail.decisionOutcomeId',
    decisionOutcomeRequestId: '$.detail.decisionOutcomeRequestId'
  },
  InputTemplate: `{
    "sourceSystem": "request-decisioning-service",
    "workflowStageType": "CONCERN_INITIATED",
    "decisionOutcomeRequestContext": {
      "decisionOutcomeRequestId": <decisionOutcomeRequestId>
    },
    "decisionOutcomeContextItems": [{
      "decisionOutcomeId": <decisionOutcomeId>
    }]
  }`
};

const { messageObject } = buildInputTransformer(inputTransformer);
console.log(messageObject);

{
  "decisionOutcomeId": "${$.detail.decisionOutcomeId}",
  "decisionOutcomeRequestId": "${$.detail.decisionOutcomeRequestId}",
  "sourceSystem": "request-decisioning-service",
  "workflowStageType": "CONCERN_INITIATED",
  "decisionOutcomeRequestContext": {
    "decisionOutcomeRequestId": "<decisionOutcomeRequestId>"
  },
  "decisionOutcomeContextItems": [
    { "decisionOutcomeId": "<decisionOutcomeId>" }
  ]
}

//Test details

src/buildInputTransformer.ts

import { aws_events as events } from "aws-cdk-lib";

export function buildInputTransformer(
  inputPathsMap: Record<string, string>,
  includeTemplate: string
): Record<string, any> {
  const messageObject: Record<string, any> = {};

  // Step 1: dynamic fields
  for (const [key, path] of Object.entries(inputPathsMap)) {
    messageObject[key] = events.EventField.fromPath(path);
  }

  // Step 2: static fields
  let parsedTemplate: Record<string, any> = {};
  try {
    parsedTemplate = JSON.parse(includeTemplate);
  } catch {
    console.warn("Invalid JSON in template, skipping parse");
  }

  // Step 3: fill missing keys from static template
  for (const [key, value] of Object.entries(parsedTemplate)) {
    if (!(key in messageObject)) {
      if (typeof value !== "string" || !value.includes("<")) {
        messageObject[key] = value;
      }
    }
  }

  return messageObject;
}

//Unit test

import { buildInputTransformer } from "../src/buildInputTransformer";
import { aws_events as events } from "aws-cdk-lib";

describe("buildInputTransformer", () => {
  it("should include dynamic and static fields", () => {
    const inputPathsMap = {
      decisionOutcomeId: "$.detail.decisionOutcomeId",
      sourceSystem: "$.detail.sourceSystem"
    };

    const includeTemplate = JSON.stringify({
      sourceSystem: "<sourceSystem>",
      workflowStageType: "ManualReview",
      staticField: "fixedValue"
    });

    const messageObject = buildInputTransformer(inputPathsMap, includeTemplate);

    // ✅ dynamic fields
    expect(messageObject.decisionOutcomeId).toEqual(
      events.EventField.fromPath("$.detail.decisionOutcomeId")
    );

    // ✅ static fields
    expect(messageObject.workflowStageType).toBe("ManualReview");
    expect(messageObject.staticField).toBe("fixedValue");

    // ✅ dynamic field should NOT be overridden
    expect(messageObject.sourceSystem).toEqual(
      events.EventField.fromPath("$.detail.sourceSystem")
    );
  });

  it("should skip invalid JSON templates gracefully", () => {
    const inputPathsMap = { id: "$.detail.id" };
    const badTemplate = '{"invalid": <notvalid>}';

    const result = buildInputTransformer(inputPathsMap, badTemplate);
    expect(result.id).toEqual(events.EventField.fromPath("$.detail.id"));
  });
});

//mocking test
// Mock aws-cdk-lib and its aws_events module
jest.mock("aws-cdk-lib", () => ({
  aws_events: {
    EventField: {
      fromPath: jest.fn((path: string) => `EventField(${path})`)
    }
  }
}));

import { buildInputTransformer } from "../src/buildInputTransformer";
import { aws_events as events } from "aws-cdk-lib";

describe("buildInputTransformer", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it("should correctly merge static and dynamic fields", () => {
    const inputPathsMap = {
      decisionOutcomeId: "$.detail.decisionOutcomeId",
      sourceSystem: "$.detail.sourceSystem"
    };

    const includeTemplate = JSON.stringify({
      sourceSystem: "<sourceSystem>",
      workflowStageType: "ManualReview",
      staticField: "fixedValue"
    });

    const messageObject = buildInputTransformer(inputPathsMap, includeTemplate);

    // ✅ dynamic fields
    expect(messageObject.decisionOutcomeId).toBe(
      "EventField($.detail.decisionOutcomeId)"
    );
    expect(messageObject.sourceSystem).toBe("EventField($.detail.sourceSystem)");

    // ✅ static fields
    expect(messageObject.workflowStageType).toBe("ManualReview");
    expect(messageObject.staticField).toBe("fixedValue");

    // ✅ ensure fromPath was called for each dynamic key
    expect(events.EventField.fromPath).toHaveBeenCalledTimes(2);
  });

  it("should skip invalid JSON and still handle dynamic fields", () => {
    const inputPathsMap = { id: "$.detail.id" };
    const badTemplate = '{"invalid": <bad>}';

    const result = buildInputTransformer(inputPathsMap, badTemplate);

    expect(result.id).toBe("EventField($.detail.id)");
    expect(events.EventField.fromPath).toHaveBeenCalledWith("$.detail.id");
  });
});








